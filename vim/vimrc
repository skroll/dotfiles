" preamble ---------------------------------------------------------------- {{{
filetype off
call pathogen#runtime_append_all_bundles()
filetype plugin indent on
set nocompatible

" }}}
" basic options ----------------------------------------------------------- {{{
set encoding=utf-8
set modelines=0
set autoindent
set showmode
set showcmd
set hidden
set visualbell
set ttyfast
set ruler
set backspace=indent,eol,start
set nonumber
set norelativenumber
set laststatus=2
set history=1000
set undofile
set undoreload=1000
set list
set listchars=tab:▸\ ,eol:¬,extends:❯,precedes:❮
set lazyredraw
set matchtime=3
set showbreak=↪
set splitbelow
set splitright
set fillchars=diff:⣿,vert:│
set autowrite
set autoread
set shiftround
set title
set linebreak
set dictionary=/usr/share/dict/words
set spellfile=~/.vim/custom-dictionary.utf-8.add
set colorcolumn=+1

" time out on key codes but not mappings.
" basically this makes terminal vim work sanely.
set notimeout
set ttimeout
set ttimeoutlen=10

" make Vim able to edit crontab files again.
set backupskip=/tmp/*,/private/tmp/*

" better Completion
set completeopt=longest,menuone,preview

" save when losing focus
au FocusLost * :silent! wall

" resize splits when the window is resized
au VimResized * :wincmd =

" Cursorline {{{
" Only show cursorline in the current window and in normal mode.
augroup cline
	au!
	au WinLeave * set nocursorline
	au WinEnter * set cursorline
	au InsertEnter * set nocursorline
	au InsertLeave * set cursorline
augroup END

" }}}
" cpoptions+=J, dammit {{{

augroup twospace
	au!
	au BufRead * :set cpoptions+=J
augroup END

" }}}
" trailing whitespace {{{
" only shown when not in insert mode so I don't go insane.

augroup trailing
	au!
	au InsertEnter * :set listchars-=trail:⌴
	au InsertLeave * :set listchars+=trail:⌴
augroup END

" }}}
" wildmenu completion {{{
set wildmenu
set wildmode=list:longest

set wildignore+=.hg,.git,.svn                    " version control
set wildignore+=*.aux,*.out,*.toc                " LaTeX intermediate files
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg   " binary images
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest " compiled object files
set wildignore+=*.spl                            " compiled spelling word lists
set wildignore+=*.sw?                            " vim swap files
set wildignore+=*.DS_Store                       " OSX bullshit

set wildignore+=*.orig                           " merge resolution files

" }}}
" line return {{{

" make sure vim returns to the same line when you repoen a file

augroup line_return
	au!
	au BufReadPost *
		\ if line("'\"") > 0 && line("'\"") <= line("$") |
		\    execute 'normal! g`"zvzz' |
		\ endif
augroup END

" }}}
" tabs, spaces, wrapping {{{
set tabstop=4
set shiftwidth=4
set softtabstop=0
set noexpandtab
set wrap
set textwidth=80
set formatoptions=qrn1
set colorcolumn=+1

set cindent
set cinoptions=(0,u0,U0

" }}}
" backups {{{

set undodir=~/.vim/tmp/undo//     " undo files
set backupdir=~/.vim/tmp/backup// " backups
set directory=~/.vim/tmp/swap//   " swap files
set backup                        " enable backups
set noswapfile                    " it's 2012, vim

" }}}
" leader {{{

let mapleader = ","
let maplocalleader = "\\"

" }}}
" color scheme {{{

syntax on
set background=dark
colorscheme badwolf

" reload the colorscheme whenever we write the file
augroup color_badwolf_dev
	au!
	au BufWritePost badwolf.vim color badwolf
augroup END

" highlight vcs conflict markers
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'

" }}}

" }}}
" convenience mappings ---------------------------------------------------- {{{

" fuck you, help key
noremap <F1> :set invfullscreen<CR>
inoremap <F1> <ESC>:set invfullscreen<CR>a

" stop it, hash key
inoremap # X<BS>#

" toggle line numbers
nnoremap <leader>n :setlocal number!<cr>

" clean trailing whitespace
nnoremap <leader>w mz:%s/\s\+$//<cr>:let @/=''<cr>`z

" send visual selection to hastebin
vnoremap <c-p> :w !haste \| tr -d '\n ' \| pbcopy && open `pbpaste`<cr>

" select entire buffer
nnoremap vaa ggVGg_
nnoremap Vaa ggVG

" change case
inoremap <C-u> <esc>mzgUiw`za

nnoremap Q gqip
vnoremap Q gq

" easier linewise selection
nnoremap <leader>V V`]

" keep the cursor in place while joining lines
nnoremap J mzJ`z

" split line
nnoremap S i<cr><esc>^mwgk:silent! s/\v +$//<cr>:noh<cr>`w

" html tag closing
inoremap <C-_> <Space><BS><Esc>:call InsertCloseTag()<cr>a

" cmdheight switching
nnoremap <leader>1 :set cmdheight=1<cr>
nnoremap <leader>2 :set cmdheight=2<cr>

" marks and quotes
noremap ' `
noremap æ '
noremap ` <C-^>

" }}}
" drag lines {{{

" <m-j> and <m-k> to drag lines in any mode
noremap ∆ :m+<CR>
noremap ˚ :m-2<CR>
inoremap ∆ <Esc>:m+<CR>
inoremap ˚ <Esc>:m-2<CR>
vnoremap ∆ :m'>+<CR>gv
vnoremap ˚ :m-2<CR>gv

"
" }}}
" insert mode completion {{{
inoremap <c-f> <c-x><c-f>
inoremap <c-]> <c-x><c-]>

" }}}

" }}}

" searching and movement -------------------------------------------------- {{{

" use sane regexes
nnoremap / /\v
vnoremap / /\v

set ignorecase
set smartcase
set incsearch
set showmatch
set hlsearch
set gdefault

set scrolloff=3
set sidescroll=1
set sidescrolloff=10

set virtualedit+=block

noremap <silent> <leader><space> :noh<cr>:call clearmatches()<cr>

" make D behave
nnoremap D d$

" don't mvoe on *
nnoremap * *<c-o>

" keep search matches in the middle of the window
nnoremap n nzzzv
nnoremap N Nzzzv

" same when jumping around
nnoremap g; g;zz
nnoremap g, g,zz

" open a quickfix window for the last search
nnoremap <silent> <leader>? :execute 'vimgrep /'.@/.'/g %'<CR>:copen<CR>

" Ack for the last search.
nnoremap <silent> <leader>/ :execute "Ack! '" . substitute(substitute(substitute(@/, "\\\\<", "\\\\b", ""), "\\\\>", "\\\\b", ""), "\\\\v", "", "") . "'"<CR>

" fix linewise visual selection of various text objects
nnoremap VV V
nnoremap Vit vitVkoj
nnoremap Vat vatV
nnoremap Vab vabV
nnoremap VaB vaBV

" directional keys {{{

" it's 2012
noremap j gj
noremap k gk
noremap gj j
noremap gk k

" easy buffer navigation
noremap <C-h> <C-w>h
noremap <C-j> <C-w>j
noremap <C-k> <C-w>k
noremap <C-l> <C-w>l

noremap <leader>v <C-w>v

" }}}
" list navigation {{{
nnoremap <left>  :cprev<cr>zvzz
nnoremap <right> :cnext<cr>zvzz
nnoremap <up>    :lprev<cr>zvzz
nnoremap <down>  :lnext<cr>zvzz

" }}}
" tab switching {{{
 
map <D-1> :tabn 1<CR>
map <D-2> :tabn 2<CR>
map <D-3> :tabn 3<CR>
map <D-4> :tabn 4<CR>
map <D-5> :tabn 5<CR>
map <D-6> :tabn 6<CR>
map <D-7> :tabn 7<CR>
map <D-8> :tabn 8<CR>
map <D-9> :tabn 9<CR>

" }}}
" folding ----------------------------------------------------------------- {{{

set foldlevelstart=999

" space to toggle folds
nnoremap <Space> za
vnoremap <Space> za

" make zO recrusively open whatever top level fold we're in, no matter where the
" cursor happens to be
nnoremap zO zCzO

function! MyFoldText() " {{{
	let line = getline(v:foldstart)

	let nucolwidth = &fdc + &number * &numberwidth
	let windowwidth = winwidth(0) - nucolwidth - 3
	let foldedlinecount = v:foldend - v:foldstart

	" expand tabs into spaces
	let onetab = strpart('        ', 0, &tabstop)
	let line = substitute(line, '\t', onetab, 'g')

	let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
	let fillcharcount = windowwidth - len(line) - len(foldedlinecount) - 4

	return line . '…' . repeat(" ",fillcharcount) . foldedlinecount . '…' . ' '
endfunction " }}}
set foldtext=MyFoldText()

" }}}
" filetype-specific ------------------------------------------------------- {{{

" c {{{

augroup ft_c
	au!
	au FileType c setlocal foldmethod=syntax
	au FileType c let fname = expand('~/src/types.vim')
	au FileType c if filereadable(fname)
	au FileType c   exe 'so ' . fname
	au FileType c endif
augroup END

" }}}
" python {{{

augroup ft_python
	au!
	au FileType python set tabstop=4
	au FileType python set shiftwidth=4
	au FileType python set softtabstop=4
	au FileType python set expandtab
augroup END

" }}}
" plugin settings --------------------------------------------------------- {{{

" ack {{{

nnoremap <leader>a :Ack!<space>

" }}}
" commentary {{{

nmap <leader>c <Plug>CommentaryLine
xmap <leader>c <Plug>Commentary

augroup plugin_commentary
	au!
	au FileType htmldjango setlocal commentstring={#\ %s\ #}
	au FileType clojurescript setlocal commentstring=;\ %s
	au FileType puppet setlocal commentstring=#\ %s
augroup END

" }}}
" ctrl-p {{{

let g:ctrlp_dont_split = 'NERD_tree_2'
let g:ctrlp_jump_to_buffer = 0
let g:ctrlp_map = '<leader>,'
let g:ctrlp_working_path_mode = 2
let g:ctrlp_match_window_reversed = 1
let g:ctrlp_split_window = 0
let g:ctrlp_max_height = 20
let g:ctrlp_extensions = ['tag']

let g:ctrlp_prompt_mappings = {
\ 'PrtSelectMove("j")':   ['<c-j>', '<down>', '<s-tab>'],
\ 'PrtSelectMove("k")':   ['<c-k>', '<up>', '<tab>'],
\ 'PrtHistory(-1)':       ['<c-n>'],
\ 'PrtHistory(1)':        ['<c-p>'],
\ 'ToggleFocus()':        ['<c-tab>'],
\ }

let ctrlp_filter_greps = "".
    \ "egrep -iv '\\.(" .
    \ "jar|class|swp|swo|log|so|o|pyc|jpe?g|png|gif|mo|po" .
    \ ")$' | " .
    \ "egrep -v '^(\\./)?(" .
    \ "deploy/|lib/|classes/|libs/|deploy/vendor/|.git/|.hg/|.svn/|.*migrations/" .
    \ ")'"

let my_ctrlp_user_command = "" .
    \ "find %s '(' -type f -or -type l ')' -maxdepth 15 -not -path '*/\\.*/*' | " .
    \ ctrlp_filter_greps

let my_ctrlp_git_command = "" .
    \ "cd %s && git ls-files | " .
    \ ctrlp_filter_greps

let g:ctrlp_user_command = ['.git/', my_ctrlp_git_command, my_ctrlp_user_command]

nnoremap <leader>. :CtrlPTag<cr>

" }}}
" easymotion {{{

let g:EasyMotion_do_mapping = 0

nnoremap <silent> <Leader>f      :call EasyMotion#F(0, 0)<CR>
onoremap <silent> <Leader>f      :call EasyMotion#F(0, 0)<CR>
vnoremap <silent> <Leader>f :<C-U>call EasyMotion#F(1, 0)<CR>

nnoremap <silent> <Leader>F      :call EasyMotion#F(0, 1)<CR>
onoremap <silent> <Leader>F      :call EasyMotion#F(0, 1)<CR>
vnoremap <silent> <Leader>F :<C-U>call EasyMotion#F(1, 1)<CR>

onoremap <silent> <Leader>t      :call EasyMotion#T(0, 0)<CR>
onoremap <silent> <Leader>T      :call EasyMotion#T(0, 1)<CR>

" }}}
" fugitive {{{

nnoremap <leader>gd  :Gdiff<cr>
nnoremap <leader>gs  :Gstatus<cr>
nnoremap <leader>gw  :Gwrite<cr>
nnoremap <leader>ga  :Gadd<cr>
nnoremap <leader>gb  :Gblame<cr>
nnoremap <leader>gco :Gcheckout<cr>
nnoremap <leader>gci :Gcommit<cr>
nnoremap <leader>gm  :Gmove<cr>
nnoremap <leader>gr  :Gremove<cr>
nnoremap <leader>gl  :Shell git gl -18<cr>:wincmd \|<cr>

augroup ft_fugitive
	au!

	au BufNewFile,BufRead .git/index setlocal nolist
augroup END

" }}}
" nerdtree {{{

noremap  <F2> :NERDTreeToggle<cr>
inoremap <F2> <esc>:NERDTreeToggle<cr>

augroup ps_nerdtree
	au!

	au Filetype nerdtree setlocal nolist
	au Filetype nerdtree nnoremap <buffer> K :q<cr>
augroup END

let NERDTreeHighlightCursorline = 1

let NERDTreeIgnore = ['.vim$', '\~$', '.*\.pyc$', 'pip-log\.txt$', 'whoosh_index',
                    \ 'xapian_index', '.*.pid', 'monitor.py', '.*-fixtures-.*.json',
                    \ '.*\.o$', 'db.db', 'tags.bak']
let NERDTreeMinimalUI = 1
let NERDTreeDirArrows = 1

" }}}
" powerline {{{

let g:Powerline_symbols = 'fancy'
let g:Powerline_cache_enabled = 1

" }}}
" syntastic {{{
let g:syntastic_disabled_filetypes = ['c', 'cpp']
let g:syntastic_enable_signs = 1
let g:syntastic_check_on_open = 0
let g:syntastic_disabled_filetypes = ['html', 'rst']
let g:syntastic_stl_format = '[%E{%e Errors}%B{, }%W{%w Warnings}]'

" }}}

" }}}
" environments (gui/console) ---------------------------------------------- {{{
if has('gui_running')
	" gui vim
	set guifont=Menlo\ Regular\ for\ Powerline:h12

	" remove all the ui cruft
	set go-=T
	set go-=l
	set go-=L
	set go-=r
	set go-=R

	highlight SpellBad term=underline gui=undercurl guisp=Orange

	" different cursors for different modes
	set guicursor=n-c:block-Cursor-blinkon0
	set guicursor+=v:block-vCursor-blinkon0
	set guicursor+=i-ci:ver20-iCursor

	if has("gui_macvim")
		" Full screen means FULL screen
		set fuoptions=maxvert,maxhorz

		" Use the normal HIG movements, except for M-Up/Down
		let macvim_skip_cmd_opt_movement = 1
		no   <D-Left>       <Home>
		no!  <D-Left>       <Home>
		no   <M-Left>       <C-Left>
		no!  <M-Left>       <C-Left>

		no   <D-Right>       <End>
		no!  <D-Right>       <End>
		no   <M-Right>       <C-Right>
		no!  <M-Right>       <C-Right>

		no   <D-Up>          <C-Home>
		ino  <D-Up>          <C-Home>
		imap <M-Up>          <C-o>{

		no   <D-Down>        <C-End>
		ino  <D-Down>        <C-End>
		imap <M-Down>        <C-o>}

		imap <M-BS>          <C-w>
		inoremap <D-BS>      <esc>my0c`y
	end
else
	" console vim
endif

