" preamble ---------------------------------------------------------------- {{{

filetype off
call pathogen#runtime_append_all_bundles()
filetype plugin indent on
set nocompatible

" }}}
" basic options ----------------------------------------------------------- {{{
set encoding=utf-8
set modelines=0
set autoindent
set showmode
set showcmd
set hidden
set visualbell
set ttyfast
set ruler
set backspace=indent,eol,start
set nonumber
set norelativenumber
set laststatus=2
set history=1000
set undofile
set undoreload=1000
set list
set listchars=tab:▸\ ,eol:¬,extends:❯,precedes:❮
set lazyredraw
set matchtime=3
set showbreak=↪
set splitbelow
set splitright
set fillchars=diff:⣿,vert:│
set autowrite
set autoread
set shiftround
set title
set linebreak
set dictionary=/usr/share/dict/words
set spellfile=~/.vim/custom-dictionary.utf-8.add
set colorcolumn=+1

set statusline=%F%m%r%h%w%=(%{&ff}/%Y)\ (line\ %l\/%L,\ col\ %c)

" time out on key codes but not mappings.
" basically this makes terminal vim work sanely.
set notimeout
set ttimeout
set ttimeoutlen=10

" make Vim able to edit crontab files again.
set backupskip=/tmp/*,/private/tmp/*

" better Completion
set completeopt=longest,menuone,preview

" save when losing focus
au FocusLost * :silent! wall

" resize splits when the window is resized
au VimResized * :wincmd =

" Cursorline {{{
" Only show cursorline in the current window and in normal mode.
augroup cline
	au!
	au WinLeave * set nocursorline
	au WinEnter * set cursorline
	au InsertEnter * set nocursorline
	au InsertLeave * set cursorline
augroup END

" }}}
" cpoptions+=J, dammit {{{

augroup twospace
	au!
	au BufRead * :set cpoptions+=J
augroup END

" }}}
" trailing whitespace {{{
" only shown when not in insert mode so I don't go insane.

augroup trailing
	au!
	au InsertEnter * :set listchars-=trail:⌴
	au InsertLeave * :set listchars+=trail:⌴
augroup END

" }}}
" wildmenu completion {{{
set wildmenu
set wildmode=list:longest

set wildignore+=.hg,.git,.svn                    " version control
set wildignore+=*.aux,*.out,*.toc                " LaTeX intermediate files
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg   " binary images
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest " compiled object files
set wildignore+=*.spl                            " compiled spelling word lists
set wildignore+=*.sw?                            " vim swap files
set wildignore+=*.DS_Store                       " OSX bullshit

set wildignore+=*.orig                           " merge resolution files

" }}}
" line return {{{

" make sure vim returns to the same line when you repoen a file

augroup line_return
	au!
	au BufReadPost *
		\ if line("'\"") > 0 && line("'\"") <= line("$") |
		\    execute 'normal! g`"zvzz' |
		\ endif
augroup END

" }}}
" tabs, spaces, wrapping {{{
set tabstop=4
set shiftwidth=4
set softtabstop=0
set noexpandtab
set wrap
set textwidth=80
set formatoptions=qrn1
set colorcolumn=+1

set cindent
set cinoptions=(0,u0,U0

" }}}
" backups {{{

set undodir=~/.vim/tmp/undo//     " undo files
set backupdir=~/.vim/tmp/backup// " backups
set directory=~/.vim/tmp/swap//   " swap files
set backup                        " enable backups
set noswapfile                    " it's 2012, vim

" }}}
" leader {{{

let mapleader = ","
let maplocalleader = "\\"

" }}}
" color scheme {{{

syntax on
set background=dark
colorscheme badwolf

" reload the colorscheme whenever we write the file
augroup color_badwolf_dev
	au!
	au BufWritePost badwolf.vim color badwolf
augroup END

" highlight vcs conflict markers
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'

" }}}

" }}}
" convenience mappings ---------------------------------------------------- {{{

" fuck you, help key
noremap <F1> :set invfullscreen<CR>
inoremap <F1> <ESC>:set invfullscreen<CR>a

" stop it, hash key
inoremap # X<BS>#

" clean trailing whitespace
nnoremap <leader>w mz:%s/\s\+$//<cr>:let @/=''<cr>`z

" send visual selection to hastebin
vnoremap <c-p> :w !haste \| tr -d '\n ' \| pbcopy && open `pbpaste`<cr>

" select entire buffer
nnoremap vaa ggVGg_
nnoremap Vaa ggVG

" change case
inoremap <C-u> <esc>mzgUiw`za

nnoremap Q gqip
vnoremap Q gq

" easier linewise selection
nnoremap <leader>V V`]

" keep the cursor in place while joining lines
nnoremap J mzJ`z

" split line
nnoremap S i<cr><esc>^mwgk:silent! s/\v +$//<cr>:noh<cr>`w

" html tag closing
inoremap <C-_> <Space><BS><Esc>:call InsertCloseTag()<cr>a

" cmdheight switching
nnoremap <leader>1 :set cmdheight=1<cr>
nnoremap <leader>2 :set cmdheight=2<cr>

" marks and quotes
noremap ' `
noremap æ '
noremap ` <C-^>

"
" }}}
" insert mode completion {{{
inoremap <c-f> <c-x><c-f>
inoremap <c-]> <c-x><c-]>

" }}}

" }}}

" searching and movement -------------------------------------------------- {{{

" use sane regexes
nnoremap / /\v
vnoremap / /\v

set ignorecase
set smartcase
set incsearch
set showmatch
set hlsearch
set gdefault

set scrolloff=3
set sidescroll=1
set sidescrolloff=10

set virtualedit+=block

noremap <silent> <leader><space> :noh<cr>:call clearmatches()<cr>

" make D behave
nnoremap D d$

" don't mvoe on *
nnoremap * *<c-o>

" keep search matches in the middle of the window
nnoremap n nzzzv
nnoremap N Nzzzv

" same when jumping around
nnoremap g; g;zz
nnoremap g, g,zz

" open a quickfix window for the last search
nnoremap <silent> <leader>? :execute 'vimgrep /'.@/.'/g %'<CR>:copen<CR>

" Ack for the last search.
nnoremap <silent> <leader>/ :execute "Ack! '" . substitute(substitute(substitute(@/, "\\\\<", "\\\\b", ""), "\\\\>", "\\\\b", ""), "\\\\v", "", "") . "'"<CR>

" fix linewise visual selection of various text objects
nnoremap VV V
nnoremap Vit vitVkoj
nnoremap Vat vatV
nnoremap Vab vabV
nnoremap VaB vaBV

" directional keys {{{

" it's 2012
noremap j gj
noremap k gk
noremap gj j
noremap gk k

" easy buffer navigation
noremap <C-h> <C-w>h
noremap <C-j> <C-w>j
noremap <C-k> <C-w>k
noremap <C-l> <C-w>l

noremap <leader>v <C-w>v

" }}}
" list navigation {{{
nnoremap <left>  :cprev<cr>zvzz
nnoremap <right> :cnext<cr>zvzz
nnoremap <up>    :lprev<cr>zvzz
nnoremap <down>  :lnext<cr>zvzz

" }}}

" }}}
" folding ----------------------------------------------------------------- {{{

set foldlevelstart=0

" space to toggle folds
nnoremap <Space> za
vnoremap <Space> za

" make zO recrusively open whatever top level fold we're in, no matter where the
" cursor happens to be
nnoremap zO zCzO

function! MyFoldText() " {{{
	let line = getline(v:foldstart)

	let nucolwidth = &fdc + &number * &numberwidth
	let windowwidth = winwidth(0) - nucolwidth - 3
	let foldedlinecount = v:foldend - v:foldstart

	" expand tabs into spaces
	let onetab = strpart('        ', 0, &tabstop)
	let line = substitute(line, '\t', onetab, 'g')

	let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
	let fillcharcount = windowwidth - len(line) - len(foldedlinecount)

	return line . '…' . repeat(" ",fillcharcount) . foldedlinecount . '…' . ' '
endfunction " }}}
set foldtext=MyFoldText()

" }}}
" filetype-specific ------------------------------------------------------- {{{

" C {{{

augroup ft_c
	au!
	au FileType c setlocal foldmethod=syntax
augroup END

" }}}

" }}}
" plugin settings --------------------------------------------------------- {{{

" Ack {{{

nnoremap <leader>a :Ack!<space>

" }}}

" Easymotion {{{

let g:EasyMotion_do_mapping = 0

nnoremap <silent> <Leader>f      :call EasyMotion#F(0, 0)<CR>
onoremap <silent> <Leader>f      :call EasyMotion#F(0, 0)<CR>
vnoremap <silent> <Leader>f :<C-U>call EasyMotion#F(1, 0)<CR>

nnoremap <silent> <Leader>F      :call EasyMotion#F(0, 1)<CR>
onoremap <silent> <Leader>F      :call EasyMotion#F(0, 1)<CR>
vnoremap <silent> <Leader>F :<C-U>call EasyMotion#F(1, 1)<CR>

onoremap <silent> <Leader>t      :call EasyMotion#T(0, 0)<CR>
onoremap <silent> <Leader>T      :call EasyMotion#T(0, 1)<CR>

" }}}


" environments (gui/console) ---------------------------------------------- {{{
if has('gui_running')
	" gui vim
	set guifont=Menlo\ Regular\ for\ Powerline:h12

	" remove all the ui cruft
	set go-=T
	set go-=l
	set go-=L
	set go-=r
	set go-=R

	highlight SpellBad term=underline gui=undercurl guisp=Orange

	" different cursors for different modes
	set guicursor=n-c:block-Cursor-blinkon0
	set guicursor+=v:block-vCursor-blinkon0
	set guicursor+=i-ci:ver20-iCursor

	if has("gui_macvim")
		" Full screen means FULL screen
		set fuoptions=maxvert,maxhorz

		" Use the normal HIG movements, except for M-Up/Down
		let macvim_skip_cmd_opt_movement = 1
		no   <D-Left>       <Home>
		no!  <D-Left>       <Home>
		no   <M-Left>       <C-Left>
		no!  <M-Left>       <C-Left>

		no   <D-Right>       <End>
		no!  <D-Right>       <End>
		no   <M-Right>       <C-Right>
		no!  <M-Right>       <C-Right>

		no   <D-Up>          <C-Home>
		ino  <D-Up>          <C-Home>
		imap <M-Up>          <C-o>{

		no   <D-Down>        <C-End>
		ino  <D-Down>        <C-End>
		imap <M-Down>        <C-o>}

		imap <M-BS>          <C-w>
		inoremap <D-BS>      <esc>my0c`y
	end
else
	" console vim
endif

"if exists('+relativenumber')
"set relativenumber
"endif
"
"if has('persistent_undo')
"set undodir=~/.vim/tmp/undodir
"set undofile
"set undoreload=10000
"endif
"
"" Status line
"
"" Backups
"set backupdir=~/.vim/tmp/backup// " backups
"set directory=~/.vim/tmp/swap//   " swap files
"set backup                        " enable backups
"
"" Leader
"let mapleader = ","
"
"" Make Y not dumb
"nnoremap Y y$
"
"" Searching
"nnoremap / /\v
"vnoremap / /\v
"set ignorecase
"set smartcase
"set gdefault
"set incsearch
"set showmatch
"set hlsearch
"nnoremap <leader><space> :noh<cr>
"nnoremap <tab> %
"vnoremap <tab> %
"
"" Soft/hard wrapping
"set wrap
"set textwidth=79
"set formatoptions=qrn1
"
"if exists('colorcolumn')
"set colorcolumn=85
"endif
"
"" Use the same symbols as TextMate for tabstops and EOLs
"set list
"set listchars=tab:▸\ ,eol:¬
"
"" Color scheme (terminal)
"syntax on
"set background=dark
""colorscheme brookstream
"colorscheme molokai
"
"" NERD Tree
"map <F2> :NERDTreeToggle<cr>
""let NERDTreeIgnore=['.vim$', '\~$', '.pyc$', '.o$', '.o.d$']
"let NERDTreeIgnore=['\.vim$', '\~$', '\.pyc$', '\.o$', '\.o.d$']
"
"" Use the damn hjkl keys
"nnoremap <up> <nop>
"nnoremap <down> <nop>
"nnoremap <left> <nop>
"nnoremap <right> <nop>
"inoremap <up> <nop>
"inoremap <down> <nop>
"inoremap <left> <nop>
"inoremap <right> <nop>
"
"" And make them fucking work, too.
"nnoremap j gj
"nnoremap k gk
"
"" Easy buffer navigation
"nnoremap <C-h> <C-w>h
"nnoremap <C-j> <C-w>j
"nnoremap <C-k> <C-w>k
"nnoremap <C-l> <C-w>l
"nnoremap <leader>w <C-w>v<C-w>l
"
"inoremap <F1> <ESC>
"nnoremap <F1> <ESC>
"vnoremap <F1> <ESC>
"inoremap jj <ESC>
"
"" Folding
"set foldlevelstart=20
"noremap <Space> za
"vnoremap <Space> za
"noremap <leader>ft Vatzf
"
"" Use syntax based folding on c files
"autocmd FileType c setlocal foldmethod=syntax
"
"" Set up python indentation
"autocmd FileType python setlocal tabstop=4
"autocmd FileType python setlocal softtabstop=4
"autocmd FileType python setlocal shiftwidth=4
"autocmd FileType python setlocal textwidth=80
"autocmd FileType python setlocal smarttab
"autocmd FileType python setlocal expandtab
"
"autocmd FileType xml setlocal tabstop=2
"autocmd FileType xml setlocal shiftwidth=2
"autocmd FileType xml setlocal expandtab
"autocmd FileType xml setlocal smarttab
"
"autocmd FileType cmake setlocal tabstop=2
"autocmd FileType cmake setlocal shiftwidth=2
"autocmd FileType cmake setlocal expandtab
"autocmd FileType cmake setlocal smarttab
"
"autocmd FileType ant setlocal tabstop=2
"autocmd FileType ant setlocal shiftwidth=2
"autocmd FileType ant setlocal expandtab
"autocmd FileType ant setlocal smarttab
"
"
"autocmd FileType html setlocal tabstop=2
"autocmd FileType html setlocal shiftwidth=2
"autocmd FileType html setlocal expandtab
"autocmd FileType html setlocal smarttab
"
"function! MyFoldText()
"	let line = getline(v:foldstart)
"
"	let nucolwidth = &fdc + &number * &numberwidth
"	let windowwidth = winwidth(0) - nucolwidth - 3
"	let foldedlinecount = v:foldend - v:foldstart
"
"	" expand tabs into spaces
"	" let onetab = strpart('          ', 0, &tabstop)
"	" let line = substitute(line, '\t', onetab, 'g')
"
"	let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
"	let fillcharcount = windowwidth - len(line) - len(foldedlinecount) - 4
"	return line . '…' . repeat(" ",fillcharcount) . foldedlinecount . '…' . ' '
"endfunction
"set foldtext=MyFoldText()
"
"inoremap <F1> <ESC>:set invfullscreen<CR>a
"nnoremap <F1> :set invfullscreen<CR>
"vnoremap <F1> :set invfullscreen<CR>
"
"" Various syntax stuff
"au BufNewFile,BufRead *.less set filetype=less
"au BufRead,BufNewFile *.scss set filetype=scss
"
"au BufRead,BufNewFile *.confluencewiki set filetype=confluencewiki
"au BufRead,BufNewFile *.confluencewiki set wrap linebreak nolist
"
"au BufNewFile,BufRead *.m*down set filetype=markdown
"au BufNewFile,BufRead *.m*down nnoremap <leader>1 yypVr=
"au BufNewFile,BufRead *.m*down nnoremap <leader>2 yypVr-
"au BufNewFile,BufRead *.m*down nnoremap <leader>3 I### <ESC>
"
"au BufNewFile,BufRead *.vim set foldmethod=marker
"
"" Clean whitespace
"nnoremap <leader>W :%s/\s\+$//<cr>:let @/=''<CR>
"
"" Ack
"nnoremap <leader>a :Ack
"
"" Fugitive
"nnoremap <leader>g :Git
"
"" Yankring
"nnoremap <silent> <F3> :YRShow<cr>
"nnoremap <silent> <leader>y :YRShow<cr>
"
"let g:yankring_history_dir = '~/.vim/tmp'
"
"" Formatting, TextMate-style
"map <leader>q qgip
"
"nmap <leader>m :make<cr>
"
"" Easier linewise reselection
"map <leader>v V`]
"
"" Scratch
"nmap <leader><tab> :Sscratch<cr><C-W>x<C-j>:resize 15<cr>
"
"" Rainbows!
"nmap <leader>R :RainbowParenthesesToggle<CR>
"
"" Edit vim stuff
"nmap <leader>ev <C-w>s<C-w>j<C-w>L:e $MYVIMRC<cr>
"nmap <leader>es <C-w>s<C-w>j<C-w>L:e ~/.vim/snippets/<cr>
"
"" Sudo to write
"cmap w!! w !sudo tee % >/dev/null
"
"" VCS Stuff
"let VCSCommandMapPrefix = "<leader>h"
"
"" Stop it, hash key
"inoremap # X<BS>#
"
"" Show syntax highlighting groups for word under cursor
"nmap <C-S> :call SynStack()<CR>
"function! SynStack()
"	if !exists("*synstack")
"		return
"	endif
"	echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
"endfunc
"
"" Tags!
"let Tlist_Ctags_Cmd = "/opt/local/bin/ctags"
"let Tlist_WinWidth = 50
"let Tlist_Show_One_File = 1
"map <F4> :TlistToggle<cr>
"
"" Gundo
"nnoremap U :GundoToggle<CR>
"let g:gundo_debug = 1
"let g:gundo_preview_bottom = 1
"
"" VimClojure
"let vimclojure#HighlightBuiltins=1
"let vimclojure#ParenRainbow=1
"
"" Tab switching
"map <D-1> :tabn 1<CR>
"map <D-2> :tabn 2<CR>
"map <D-3> :tabn 3<CR>
"map <D-4> :tabn 4<CR>
"map <D-5> :tabn 5<CR>
"map <D-6> :tabn 6<CR>
"map <D-7> :tabn 7<CR>
"map <D-8> :tabn 8<CR>
"map <D-9> :tabn 9<CR>
"
"map <Leader>, :NERDTreeToggle<cr>
"
"if has('gui_running')
"	set guifont=Menlo:h12
"	set background=dark
"	colorscheme molokai
"	"colorscheme camo2
"	"colorscheme solarized
"
"	set go-=T
"	set go-=l
"	set go-=L
"	set go-=r
"	set go-=R
"
"	if has("gui_macvim")
"		macmenu &File.New\ Tab key=<nop>
"		map <leader>t <Plug>PeepOpen
"	end
"
"	let g:sparkupExecuteMapping = '<D-e>'
"	" Fuck you, help key
"	set fuoptions=maxvert,maxhorz
"
"	"highlight SpellBad term=underline gui=undercurl guisp=Orange
"endif
"
"" Load types if we are in a directory that is in a project i'm on.
"autocmd BufRead ~/src/work/igc/*.[ch] exe 'source ~/src/work/igc/types.vim'
"autocmd BufRead ~/src/work/igc/*.[ch] exe 'set tags+=~/src/work/igc/tags'
"
"" autocmd BufRead ~/src/work/mv/*.[ch] exe 'source ~/src/work/mv/types.vim'
"" autocmd BufRead ~/src/work/mv/*.[ch] exe 'set tags+=~/src/work/mv/tags'
"autocmd BufRead CMakeLists*.txt exe 'set filetype=cmake'
"
""command! UMenu silent: exe "!understand -existing -contextmenu %:p -line " line(‘.’) " -col " col(‘.’) " -text <cword> &" | redraw!
"command! UMenu silent: exe "!understand -existing -contextmenu " . expand("%:p") . " -line " . line(".") . " -col " . col(".") . " -text <cword> &" | redraw!
""command! UMenu silent: exe "!understand -existing -visit " . expand("%:p") . " " . line(".") . " " . col(".") . " &" | redraw!
""map <C-u> :UMenu<CR>
"
"" clang_complete settings
""let g:clang_use_library = 1
""let g:clang_library_path = '/usr/lib'
""let g:clang_snippets = 1
""let g:clang_snippets_engine = 'ultisnips'
""
""map <C-a> :UMenu<CR>
